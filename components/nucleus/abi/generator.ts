import type { AbiEntry, StructEntry, EnumEntry, FunctionEntry, TypeAliasEntry, Field, TypeDefinition } from "./types";

export async function generateCode(
  entries: AbiEntry[],
): Promise<string> {
  const imports = new Set<string>();
  const functionDefinitions: string[] = [];

  imports.add("U8aFixed");
  imports.add("Null");
  imports.add("Enum");
  imports.add("i8");
  imports.add("u8");
  imports.add("u16");
  imports.add("u32");
  imports.add("U32");
  imports.add("U64");
  imports.add("I64");
  imports.add("u128");
  imports.add("U128");
  imports.add("I32");
  imports.add("Result");
  imports.add("Vec");
  imports.add("Tuple");
  imports.add("Option");
  imports.add("bool");
  imports.add("Text");
  imports.add("Struct");

  const { typeDefinitions, registeredTypes } = generateTypesInDependencyOrder(entries);
  
  const functions = entries.filter((entry): entry is FunctionEntry => entry.type === "fn");
  for (const func of functions) {
    const functionCode = generateFunction(func, entries);
    functionDefinitions.push(functionCode);
  }

  const code = `/**
 * This is an automatically generated file. DO NOT MODIFY IT DIRECTLY.
 * Generated by nabi-ts code generator.
 * WARNING: Any manual changes to this file will be overwritten on next generation
 */
import {
  ${Array.from(imports).join(',\n  ')}
} from '@polkadot/types-codec';
import { ApiPromise, HttpProvider } from "@polkadot/api";
import { TypeRegistry } from '@polkadot/types';
import type { Registry, Codec } from '@polkadot/types/types';
import type { U8aBitLength } from '@polkadot/types-codec/types';

export const registry: Registry = new TypeRegistry() as unknown as Registry;
let api: ApiPromise;

export async function initApi(endpoint: string): Promise<ApiPromise> {
  const provider = new HttpProvider(endpoint);
  api = await ApiPromise.create({ 
    provider,
    registry 
  });
  return api;
}

${typeDefinitions.join('\n\n')}

${functionDefinitions.join('\n\n')}

function registerTypes(): Registry {
  try {
    registry.register({
${registeredTypes.map(type => `      ${type}: ${type}`).join(',\n')}
    });
  } catch (error) {
    console.warn('type register error:', error);
  }
  
  return registry;
}

registerTypes();
`;

  return code;
}

function convertPolkadotClassType(type: TypeDefinition): string {
  switch (type.kind) {
    case "Path":
      if (!type.path || type.path.length === 0) {
        return "Codec";
      }
      
      const typeName = type.path[type.path.length - 1];
      
      switch (typeName) {
        case "u8": return "u8";
        case "u16": return "u16";
        case "u32": return "U32";
        case "u64": return "U64";
        case "u128": return "U128";
        case "i8": return "i8";
        case "i16": return "i16";
        case "i32": return "I32";
        case "i64": return "I64";
        case "i128": return "I128";
        case "bool": return "bool";
        case "String": return "Text";
        case "Vec":
          if (type.generic_args && type.generic_args.length > 0) {
            const innerType = convertPolkadotClassType(type.generic_args[0]!);
            return `Vec.with(${innerType})`;
          }
          return "Vec";
        case "Option":
          if (type.generic_args && type.generic_args.length > 0) {
            const innerType = convertPolkadotClassType(type.generic_args[0]!);
            return `Option.with(${innerType})`;
          }
          return "Option";
        case "Result":
          if (type.generic_args && type.generic_args.length === 2) {
            const okType = convertPolkadotClassType(type.generic_args[0]!);
            const errType = convertPolkadotClassType(type.generic_args[1]!);
            return `Result.with({ Ok: ${okType}, Err: ${errType} })`;
          }
          return "Result";
        default:
          return typeName || "Codec";
      }
      
    case "Tuple":
      if (!type.tuple_args || type.tuple_args.length === 0) {
        return "Null";
      }
      const tupleTypes = type.tuple_args.map(t => convertPolkadotClassType(t)).join(', ');
      return `Tuple.with([${tupleTypes}])`;
      
    case "Array":
      if (type.elem && type.len) {
        const elemType = convertPolkadotClassType(type.elem);
        if (type.elem.kind === "Path" && type.elem.path && type.elem.path[type.elem.path.length - 1] === "u8") {
          // [u8; 10] -> U8aFixed.with(80) (10 bytes = 80 bits)
          return `U8aFixed.with(${type.len * 8} as U8aBitLength)`;
        } else {
          return `Vec.with(${elemType})`;
        }
      }
      return "Vec";
      
    default:
      return "Codec";
  }
}

function convertPolkadotType(type: TypeDefinition): string {
  switch (type.kind) {
    case "Path":
      if (!type.path || type.path.length === 0) {
        return "unknown";
      }
      
      const typeName = type.path[type.path.length - 1];
      
      switch (typeName) {
        case "u8": return "u8";
        case "u16": return "u16";
        case "u32": return "U32";
        case "u64": return "U64";
        case "u128": return "U128";
        case "i8": return "i8";
        case "i16": return "i16";
        case "i32": return "I32";
        case "i64": return "I64";
        case "i128": return "I128";
        case "bool": return "bool";
        case "String": return "Text";
        case "H160": return "U8aFixed.with(160 as U8aBitLength)";
        case "Vec":
          if (type.generic_args && type.generic_args.length > 0) {
            return `Vec.with(${convertPolkadotType(type.generic_args[0]!)})`;
          }
          return "Vec";
        case "Option":
          if (type.generic_args && type.generic_args.length > 0) {
            return `Option.with(${convertPolkadotType(type.generic_args[0]!)})`;
          }
          return "Option";
        case "Result":
          if (type.generic_args && type.generic_args.length === 2) {
            return `Result.with({\n    Ok: ${convertPolkadotType(type.generic_args[0]!)},\n    Err: ${convertPolkadotType(type.generic_args[1]!)}\n  })`;
          }
          return "Result";
        default:
          if (typeName === "T" || typeName === "S") {
            return typeName;
          }
          return typeName || "Codec";
      }
      
    case "Tuple":
      if (!type.tuple_args || type.tuple_args.length === 0) {
        return "Null";
      }
      const tupleTypes = type.tuple_args.map(t => convertPolkadotType(t)).join(', ');
      return `Tuple.with([${tupleTypes}])`;
      
    default:
      return "unknown";
  }
}

function generateFunction(func: FunctionEntry, entries?: AbiEntry[]): string {
  const params = ['nucleusId: string'];
  const paramProcessing: string[] = [];
  
  if (func.inputs.length === 0) {
    const rpcParams = ['nucleusId', `'${func.name}'`, '""'];
    
    let returnTypeProcessing = '';
    if (func.output) {
      const resultType = generateReturnType(func.output);
      returnTypeProcessing = `
  const responseBytes = Buffer.from(response as string, "hex");
  return new ${resultType}(registry, responseBytes);`;
    } else {
      returnTypeProcessing = `
  return response as any;`;
    }
    
    return `export async function ${func.name}(${params.join(', ')}): Promise<any> {
  if (!api) throw new Error('API not initialized');

  const response = await api.rpc('nucleus_${func.method}', ${rpcParams.join(', ')});
${returnTypeProcessing}
}`;
  } else if (func.inputs.length === 1) {
    const input = func.inputs[0]!;
    const paramName = `${input.name}Arg`;
    params.push(`${paramName}: any`);
    
    const varName = input.name;
    const constructorCall = generateConstructorCall(input.type, paramName, entries);
    
    paramProcessing.push(`  const ${varName} = ${constructorCall};`);
    
    const rpcParams = ['nucleusId', `'${func.name}'`, `${input.name}?.toHex()`];
    
    let returnTypeProcessing = '';
    if (func.output) {
      const resultType = generateReturnType(func.output);
      returnTypeProcessing = `
  const responseBytes = Buffer.from(response as string, "hex");
  return new ${resultType}(registry, responseBytes);`;
    } else {
      returnTypeProcessing = `
  return response as any;`;
    }
    
    return `export async function ${func.name}(${params.join(', ')}): Promise<any> {
  if (!api) throw new Error('API not initialized');
${paramProcessing.join('\n')}
  const response = await api.rpc('nucleus_${func.method}', ${rpcParams.join(', ')});
${returnTypeProcessing}
}`;
  } else {
    for (const input of func.inputs) {
      const paramName = `${input.name}Arg`;
      params.push(`${paramName}: any`);
    }
    
    const tupleTypes = func.inputs.map(input => convertPolkadotClassType(input.type));
    const paramNames = func.inputs.map(input => `${input.name}Arg`);
    const tupleConstructorCall = `new Tuple(registry, [${tupleTypes.join(', ')}], [${paramNames.join(', ')}])`;
    
    paramProcessing.push(`  const args = ${tupleConstructorCall};`);
    
    const rpcParams = ['nucleusId', `'${func.name}'`, 'args?.toHex()'];
    
    let returnTypeProcessing = '';
    if (func.output) {
      const resultType = generateReturnType(func.output);
      returnTypeProcessing = `
  const responseBytes = Buffer.from(response as string, "hex");
  return new ${resultType}(registry, responseBytes);`;
    } else {
      returnTypeProcessing = `
  return response as any;`;
    }
    
    return `export async function ${func.name}(${params.join(', ')}): Promise<any> {
  if (!api) throw new Error('API not initialized');
${paramProcessing.join('\n')}
  const response = await api.rpc('nucleus_${func.method}', ${rpcParams.join(', ')});
${returnTypeProcessing}
}`;
  }
}

function generateReturnType(type: TypeDefinition): string {
  switch (type.kind) {
    case "Path":
      if (!type.path || type.path.length === 0) {
        return "Codec";
      }
      
      const typeName = type.path[type.path.length - 1];
      
      switch (typeName) {
        case "u8": return "u8";
        case "u16": return "u16";
        case "u32": return "U32";
        case "u64": return "U64";
        case "u128": return "U128";
        case "i8": return "i8";
        case "i16": return "i16";
        case "i32": return "I32";
        case "i64": return "I64";
        case "i128": return "I128";
        case "bool": return "bool";
        case "String": return "Text";
        case "H160": return "U8aFixed";
        case "Vec":
          if (type.generic_args && type.generic_args.length > 0) {
            const innerType = generateReturnType(type.generic_args[0]!);
            return `(Vec.with(${innerType}))`;
          }
          return "Vec";
        case "Option":
          if (type.generic_args && type.generic_args.length > 0) {
            const innerType = generateReturnType(type.generic_args[0]!);
            return `(Option.with(${innerType}))`;
          }
          return "Option";
        case "Result":
          if (type.generic_args && type.generic_args.length === 2) {
            const okType = generateReturnType(type.generic_args[0]!);
            const errType = generateReturnType(type.generic_args[1]!);
            return `(Result.with({ Ok: ${okType}, Err: ${errType} }))`;
          }
          return "Result";
        default:
          return typeName || "Codec";
      }
      
    case "Tuple":
      if (!type.tuple_args || type.tuple_args.length === 0) {
        return "Null";
      }
      const tupleTypes = type.tuple_args.map(t => generateReturnType(t)).join(', ');
      return `(Tuple.with([${tupleTypes}]))`;
      
    default:
      return "Codec";
  }
}

function generateConstructorCall(type: TypeDefinition, paramName: string, entries?: AbiEntry[]): string {
  switch (type.kind) {
    case "Path":
      if (!type.path || type.path.length === 0) {
        return `new Codec(registry, ${paramName})`;
      }
      
      const typeName = type.path[type.path.length - 1];
      
      switch (typeName) {
        case "Vec":
          if (type.generic_args && type.generic_args.length > 0) {
            const innerType = convertPolkadotClassType(type.generic_args[0]!);
            return `new Vec(registry, ${innerType}, ${paramName})`;
          }
          return `new Vec(registry, ${paramName})`;
        case "Option":
          if (type.generic_args && type.generic_args.length > 0) {
            const innerType = convertPolkadotClassType(type.generic_args[0]!);
            return `new Option(registry, ${innerType}, ${paramName})`;
          }
          return `new Option(registry, ${paramName})`;
        case "Result":
          if (type.generic_args && type.generic_args.length === 2) {
            const okType = convertPolkadotClassType(type.generic_args[0]!);
            const errType = convertPolkadotClassType(type.generic_args[1]!);
            return `new Result(registry, { Ok: ${okType}, Err: ${errType} }, ${paramName})`;
          }
          return `new Result(registry, ${paramName})`;
        default:
          if (type.generic_args && type.generic_args.length > 0 && entries) {
            const typeEntry = entries.find(entry => 
              entry.type === "type_alias" && entry.name === typeName && 
              entry.generics && entry.generics.length > 0
            ) as TypeAliasEntry | undefined;
            
            if (typeEntry) {
              const genericArgs: string[] = ['registry'];
              
              type.generic_args.forEach(arg => {
                genericArgs.push(convertPolkadotClassType(arg));
              });
              
              genericArgs.push(paramName);
              
              return `new ${typeName}(${genericArgs.join(', ')})`;
            }
          }
          
          const polkadotType = convertPolkadotClassType(type);
          return `new ${polkadotType}(registry, ${paramName})`;
      }
      
    case "Tuple":
      if (!type.tuple_args || type.tuple_args.length === 0) {
        return `new Null(registry, ${paramName})`;
      }
      const tupleTypes = type.tuple_args.map(t => convertPolkadotClassType(t)).join(', ');
      return `new Tuple(registry, [${tupleTypes}], ${paramName})`;
      
    default:
      return `new Codec(registry, ${paramName})`;
  }
}

function generateGenericTypeAlias(alias: TypeAliasEntry, entries: AbiEntry[]): string {
  const targetTypeName = alias.target.path?.[alias.target.path.length - 1];
  if (!targetTypeName) {
    const targetType = convertPolkadotClassType(alias.target);
    return `export class ${alias.name} extends ${targetType} {
  constructor(registry: Registry, value?: any) {
    super(registry, value);
  }
}`;
  }

  // G<T> = Result<T, String>
  if (targetTypeName === "Result" && alias.target.generic_args && alias.target.generic_args.length === 2) {
    const genericParams = alias.generics?.join(', ') || '';
    const constructorGenericParams = alias.generics?.map(g => `${g}: any`).join(', ') || '';
    
    const okType = alias.target.generic_args[0];
    const errType = alias.target.generic_args[1];
    
    let okTypeStr: string;
    let errTypeStr: string;
    
    if (okType?.kind === "Path" && okType?.path && okType?.path[0]) {
      const okTypeName = okType.path[0];
      if (alias.generics?.includes(okTypeName)) {
        okTypeStr = okTypeName;
      } else {
        okTypeStr = convertPolkadotClassType(okType);
      }
    } else {
      okTypeStr = convertPolkadotClassType(okType!);
    }
    
    errTypeStr = convertPolkadotClassType(errType!);
    
    return `export class ${alias.name}<${genericParams} extends Codec> extends Result<${okTypeStr}, ${errTypeStr}> {
  constructor(registry: Registry, ${constructorGenericParams}${constructorGenericParams ? ', ' : ''}value?: any) {
    super(registry, ${okTypeStr}, ${errTypeStr}, value);
  }
}`;
  }

  const targetStruct = entries.find(entry => 
    entry.type === "struct" && entry.name === targetTypeName
  ) as StructEntry | undefined;

  if (targetStruct && targetStruct.generics && targetStruct.generics.length > 0) {
    // SignedArgs<T> = Args<T, EcdsaSignature>
    
    const genericParams = alias.generics?.map(g => `${g}: any`).join(', ') || '';
    
    const superArgs: string[] = ['registry'];
    
    if (alias.target.generic_args) {
      alias.target.generic_args.forEach(arg => {
        if (arg.kind === "Path" && arg.path && arg.path.length === 1) {
          const argTypeName = arg.path[0]!;
          if (alias.generics?.includes(argTypeName)) {
            superArgs.push(argTypeName);
          } else {
            superArgs.push(convertPolkadotClassType(arg));
          }
        } else {
          superArgs.push(convertPolkadotClassType(arg));
        }
      });
    }
    
    superArgs.push('value');
    
    return `export class ${alias.name} extends ${targetTypeName} {
  constructor(registry: Registry, ${genericParams}${genericParams ? ', ' : ''}value?: any) {
    super(${superArgs.join(', ')});
  }
}`;
  }

  if (!targetStruct) {
    const targetType = convertPolkadotClassType(alias.target);
    return `export class ${alias.name} extends ${targetType} {
  constructor(registry: Registry, value?: any) {
    super(registry, value);
  }
}`;
  }

  const genericMap = new Map<string, TypeDefinition>();
  if (alias.target.generic_args && alias.generics) {
    for (let i = 0; i < Math.min(alias.target.generic_args.length, alias.generics.length); i++) {
      genericMap.set(alias.generics[i]!, alias.target.generic_args[i]!);
    }
  }

  const fields = targetStruct.fields.map(field => {
    let fieldType: TypeDefinition = field.type;
    
    if (field.type.kind === "Path" && field.type.path && field.type.path.length === 1) {
      const typeName = field.type.path[0]!;
      if (genericMap.has(typeName)) {
        fieldType = genericMap.get(typeName)!;
      }
    }
    
    const polkadotType = convertPolkadotClassType(fieldType);
    return `    ${field.name}: '${polkadotType}'`;
  }).join(',\n');

  return `export class ${alias.name} extends Struct {
  constructor(registry: Registry, value?: any) {
    super(registry, {
${fields}
    }, value);
  }
}`;
}

function generateEnum(enumEntry: EnumEntry): string {
  const variants: string[] = [];
  
  for (const variant of enumEntry.variants) {
    if (variant.fields.length === 0) {
      variants.push(`      ${variant.name}: Null`);
    } else if (variant.fields.length === 1 && variant.fields[0]?.name === "_0") {
      const fieldType = convertPolkadotClassType(variant.fields[0]!.type);
      variants.push(`      ${variant.name}: ${fieldType}`);
    } else {
      const fields = variant.fields.map(field => {
        const fieldType = convertPolkadotClassType(field.type);
        return `        ${field.name}: ${fieldType}`;
      }).join(',\n');
      
      variants.push(`      ${variant.name}: Struct.with({\n${fields}\n      })`);
    }
  }
  
  return `export class ${enumEntry.name} extends Enum {
  constructor(registry: Registry, value?: any) {
    super(registry, {
${variants.join(',\n')}
    }, value);
  }
}`;
}

function generateTypesInDependencyOrder(entries: AbiEntry[]): { typeDefinitions: string[], registeredTypes: string[] } {
  const typeDefinitions: string[] = [];
  const registeredTypes: string[] = [];
  const typeMap = new Map<string, AbiEntry>();
  const dependencies = new Map<string, Set<string>>();
  const processed = new Set<string>();
  
  entries.forEach(entry => {
    if (entry.type !== "fn") {
      typeMap.set(entry.name, entry);
    }
  });
  
  function collectTypeDependencies(type: TypeDefinition): Set<string> {
    const deps = new Set<string>();
    
    if (type.kind === "Path" && type.path && type.path.length > 0) {
      const typeName = type.path[type.path.length - 1]!;
      const basicTypes = ["u8", "u16", "u32", "u64", "u128", "i8", "i16", "i32", "i64", "i128", 
                         "bool", "String", "Vec", "Option", "Result"];
      if (!basicTypes.includes(typeName) && typeMap.has(typeName)) {
        deps.add(typeName);
      }
    }
    
    if (type.generic_args) {
      type.generic_args.forEach(arg => {
        collectTypeDependencies(arg).forEach(dep => deps.add(dep));
      });
    }
    if (type.tuple_args) {
      type.tuple_args.forEach(arg => {
        collectTypeDependencies(arg).forEach(dep => deps.add(dep));
      });
    }
    
    return deps;
  }
  
  typeMap.forEach((entry, typeName) => {
    const deps = new Set<string>();
    
    if (entry.type === "struct") {
      entry.fields.forEach(field => {
        collectTypeDependencies(field.type).forEach(dep => deps.add(dep));
      });
    } else if (entry.type === "enum") {
      entry.variants.forEach(variant => {
        variant.fields.forEach(field => {
          collectTypeDependencies(field.type).forEach(dep => deps.add(dep));
        });
      });
    } else if (entry.type === "type_alias" && entry.target) {
      collectTypeDependencies(entry.target).forEach(dep => deps.add(dep));
    }
    
    deps.delete(typeName);
    dependencies.set(typeName, deps);
  });
  
  function processType(typeName: string) {
    if (processed.has(typeName)) {
      return;
    }
    
    const entry = typeMap.get(typeName);
    if (!entry) {
      typeDefinitions.push(`export const ${typeName} = 'Codec';`);
      registeredTypes.push(typeName);
      processed.add(typeName);
      return;
    }
    
    const deps = dependencies.get(typeName) || new Set();
    deps.forEach(dep => {
      if (!processed.has(dep)) {
        processType(dep);
      }
    });
    
    if (entry.type === "type_alias") {
      if (entry.generics && entry.generics.length > 0) {
        console.log(`Processing generic type alias: ${entry.name}, generics: ${entry.generics}`);
        const aliasCode = generateGenericTypeAlias(entry, Array.from(typeMap.values()));
        typeDefinitions.push(aliasCode);
      } else {
        const targetType = convertPolkadotClassType(entry.target);
        typeDefinitions.push(`export const ${entry.name} = ${targetType};`);
      }
    } else if (entry.type === "struct") {
      const structCode = generateStruct(entry);
      typeDefinitions.push(structCode);
    } else if (entry.type === "enum") {
      const enumCode = generateEnum(entry);
      typeDefinitions.push(enumCode);
    }
    
    registeredTypes.push(typeName);
    processed.add(typeName);
  }
  
  typeMap.forEach((_, typeName) => {
    processType(typeName);
  });
  
  const referencedTypes = new Set<string>();
  const definedTypes = new Set<string>();
  
  typeMap.forEach((_, typeName) => definedTypes.add(typeName));
  
  function collectReferencedTypes(type: TypeDefinition) {
    if (type.kind === "Path" && type.path && type.path.length > 0) {
      const typeName = type.path[type.path.length - 1]!;
      const basicTypes = ["u8", "u16", "u32", "u64", "u128", "i8", "i16", "i32", "i64", "i128", 
                         "bool", "String", "Vec", "Option", "Result"];
      if (!basicTypes.includes(typeName)) {
        referencedTypes.add(typeName);
      }
    }
    
    if (type.generic_args) {
      type.generic_args.forEach(collectReferencedTypes);
    }
    if (type.tuple_args) {
      type.tuple_args.forEach(collectReferencedTypes);
    }
  }
  
  entries.forEach(entry => {
    if (entry.type === "struct") {
      entry.fields.forEach(field => collectReferencedTypes(field.type));
    } else if (entry.type === "fn") {
      entry.inputs.forEach(input => collectReferencedTypes(input.type));
      if (entry.output) {
        collectReferencedTypes(entry.output);
      }
    } else if (entry.type === "type_alias" && entry.target) {
      collectReferencedTypes(entry.target);
    }
  });
  
  return { typeDefinitions, registeredTypes };
}

function generateStruct(struct: StructEntry): string {
  if (struct.generics && struct.generics.length > 0) {
    const genericParams = struct.generics.map(g => `${g}: any`).join(', ');
    const fields = struct.fields.map(field => {
      let fieldType: string;
      if (field.type.kind === "Path" && field.type.path && field.type.path.length === 1) {
        const typeName = field.type.path[0]!;
        if (struct.generics!.includes(typeName)) {
          fieldType = typeName;
        } else {
          fieldType = convertPolkadotClassType(field.type);
        }
      } else {
        fieldType = convertPolkadotClassType(field.type);
      }
      return `    ${field.name}: ${fieldType}`;
    }).join(',\n');

    return `export class ${struct.name} extends Struct {
  constructor(registry: Registry, ${genericParams}, value?: any) {
    super(registry, {
${fields}
    }, value);
  }
}`;
  } else {
    // （tuple struct）
    if (struct.fields.length === 1 && struct.fields[0]?.name === "_0") {
      const field = struct.fields[0];
      // H160([u8; 20])
      if (field.type.kind === "Array" && field.type.elem) {
        const elemType = field.type.elem;
        if (elemType.kind === "Path" && elemType.path && elemType.path[elemType.path.length - 1] === "u8" && field.type.len) {
          //  [u8; 20] -> U8aFixed.with(160) (20 bytes = 160 bits)
          return `export const ${struct.name} = U8aFixed.with(${field.type.len * 8} as U8aBitLength);`;
        } else {
          const arrayType = convertPolkadotClassType(field.type);
          return `export const ${struct.name} = ${arrayType};`;
        }
      } else {
        const fieldType = convertPolkadotClassType(field.type);
        return `export const ${struct.name} = ${fieldType};`;
      }
    } else {
      const fields = struct.fields.map(field => {
        const fieldType = convertPolkadotClassType(field.type);
        return `    ${field.name}: ${fieldType}`;
      }).join(',\n');

      return `export class ${struct.name} extends Struct {
  constructor(registry: Registry, value?: any) {
    super(registry, {
${fields}
    }, value);
  }
}`;
    }
  }
}